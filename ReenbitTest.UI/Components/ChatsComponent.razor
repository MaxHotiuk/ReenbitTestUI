@using ReenbitTest.UI.Interfaces
@using ReenbitTest.UI.Models
@inject IChatService ChatService
@inject IChatHubService ChatHubService
@inject IAuthService AuthService
@inject NavigationManager NavigationManager
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IJSRuntime JSRuntime
@inject ReenbitTest.UI.Services.NavbarEventService NavbarEventService

<MudPaper Class="d-flex flex-column h-100" Elevation="0" Square="true">
    <MudToolBar Dense="true" DisableGutters="true" Class="px-2">
        <MudText Typo="Typo.subtitle1" Class="mud-text-truncate">Chats</MudText>
        <MudSpacer />
        <MudTooltip Text="New Chat">
            <MudIconButton Icon="@Icons.Material.Filled.Add" 
                          Size="Size.Small"
                          Color="Color.Primary" 
                          OnClick="OpenNewChatDialog" />
        </MudTooltip>
    </MudToolBar>

    <MudDivider />

    @if (_isLoading)
    {
        <MudContainer Class="d-flex justify-center my-4">
            <MudProgressCircular Color="Color.Primary" Size="Size.Small" Indeterminate="true" />
        </MudContainer>
    }
    else if (_chatRooms.Count == 0)
    {
        <MudContainer Class="d-flex justify-center align-center my-4">
            <MudText Typo="Typo.caption" Class="text-center mud-text-secondary">
                No chats yet
            </MudText>
        </MudContainer>
    }
    else
    {
        <MudList T="string" Clickable="true" DisablePadding="true" Class="overflow-y-auto flex-grow-1 pa-0">
            @foreach (var chat in _chatRooms)
            {
                <MudListItem OnClick="@(() => SelectChat(chat))" 
                            Class="@GetChatItemClass(chat.Id)" 
                            Dense="true">
                    <div class="d-flex flex-column w-100 py-1">
                        <div class="d-flex justify-space-between align-center">
                            <MudText Typo="Typo.body2" Class="mud-text-truncate" Style="max-width: 75%;">
                                @chat.Name
                            </MudText>
                            @if (_unreadMessages.TryGetValue(chat.Id, out var unread) && unread > 0)
                            {
                                <MudBadge Color="Color.Secondary" Content="@unread" Overlap="true" Max="99" Class="ml-1">
                                    <MudIcon Icon="@Icons.Material.Filled.Circle" Size="Size.Small" />
                                </MudBadge>
                            }
                        </div>
                        <MudText Typo="Typo.caption" Class="mud-text-truncate" Style="opacity: 0.7;">
                            @GetLastMessagePreview(chat.Id)
                        </MudText>
                    </div>
                </MudListItem>
            }
        </MudList>
    }

    @if (_typingUsers.Any())
    {
        <MudPaper Elevation="0" Class="mt-auto pa-2" Style="min-height: 24px;">
            @foreach (var typingInfo in _typingUsers)
            {
                <MudText Typo="Typo.caption" Class="mud-text-secondary d-block">
                    <em>@typingInfo.Value is typing...</em>
                </MudText>
            }
        </MudPaper>
    }
</MudPaper>

@code {
    [Parameter]
    public EventCallback<int> OnChatSelected { get; set; }

    private bool _isLoading = true;
    private List<ChatRoom> _chatRooms = new();
    private Dictionary<int, Message> _lastMessages = new();
    private Dictionary<int, int> _unreadMessages = new();
    private Dictionary<string, string> _typingUsers = new();
    private int? _selectedChatId;
    private Timer? _typingTimer;
    private bool _connectionInitialized = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadChatRooms();

        // Check URL for chat ID
        var uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        if (int.TryParse(uri.AbsolutePath.Trim('/'), out var chatId))
        {
            await SelectChat(_chatRooms.FirstOrDefault(c => c.Id == chatId));
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && AuthService.IsAuthenticated && !_connectionInitialized)
        {
            await InitializeHubConnection();
        }
    }

    private async Task InitializeHubConnection()
    {
        try
        {
            var token = await AuthService.GetTokenAsync();
            if (string.IsNullOrEmpty(token))
                return;

            await ChatHubService.StartConnectionAsync(token);
            
            ChatHubService.OnReceiveMessage += HandleReceiveMessage;
            ChatHubService.OnUserTyping += HandleUserTyping;
            ChatHubService.OnUserStoppedTyping += HandleUserStoppedTyping;
            ChatHubService.OnError += HandleError;

            _connectionInitialized = true;

            // Join all chat rooms
            foreach (var chat in _chatRooms)
            {
                await ChatHubService.JoinChatRoomAsync(chat.Id);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Connection error: {ex.Message}", Severity.Error);
        }
    }

    private void HandleReceiveMessage(Message message)
    {
        _lastMessages[message.ChatRoomId] = message;
        
        // If message is not from current user and not in the currently selected chat
        if (!message.IsCurrentUser && _selectedChatId != message.ChatRoomId)
        {
            if (!_unreadMessages.TryGetValue(message.ChatRoomId, out var count))
            {
                count = 0;
            }
            _unreadMessages[message.ChatRoomId] = count + 1;
        }
        
        InvokeAsync(StateHasChanged);
    }

    private void HandleUserTyping(UserTypingInfo typingInfo)
    {
        if (typingInfo.UserId != AuthService.CurrentUser?.Id)
        {
            _typingUsers[typingInfo.UserId] = typingInfo.UserName;
            InvokeAsync(StateHasChanged);
            
            // Clear typing indicator after 3 seconds of inactivity
            _typingTimer?.Dispose();
            _typingTimer = new Timer(_ => 
            {
                _typingUsers.Remove(typingInfo.UserId);
                InvokeAsync(StateHasChanged);
            }, null, 3000, Timeout.Infinite);
        }
    }

    private void HandleUserStoppedTyping(UserTypingInfo typingInfo)
    {
        if (_typingUsers.ContainsKey(typingInfo.UserId))
        {
            _typingUsers.Remove(typingInfo.UserId);
            InvokeAsync(StateHasChanged);
        }
    }

    private void HandleError(string error)
    {
        Snackbar.Add(error, Severity.Error);
    }

    private async Task LoadChatRooms()
    {
        try
        {
            _isLoading = true;
            _chatRooms = await ChatService.GetChatRoomsAsync();
            
            // Load last message for each chat
            foreach (var chat in _chatRooms)
            {
                var messages = await ChatService.GetMessagesForChatRoomAsync(chat.Id, 1, 1);
                if (messages.Count > 0)
                {
                    _lastMessages[chat.Id] = messages[0];
                }
            }
            
            _isLoading = false;
        }
        catch (Exception ex)
        {
            _isLoading = false;
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
    }

    private async Task SelectChat(ChatRoom? chat)
    {
        if (chat == null || chat.Id == _selectedChatId) return;
        
        _selectedChatId = chat.Id;
        
        // Clear unread count for this chat
        _unreadMessages[chat.Id] = 0;
        
        // Navigate to the chat page with the chat ID
        NavigationManager.NavigateTo($"/{chat.Id}");
        
        // Toggle the navbar closed on small screens
        if (await IsSmallScreenAsync())
        {
            NavbarEventService.ToggleNavbar();
        }
        
        await OnChatSelected.InvokeAsync(chat.Id);
        StateHasChanged();
    }

    // Helper to check screen size
    private async Task<bool> IsSmallScreenAsync()
    {
        try
        {
            // Check if current width is less than 600px (typical small screen breakpoint)
            var windowWidth = await JSRuntime.InvokeAsync<int>("getWindowWidth");
            return windowWidth < 960;
        }
        catch
        {
            // Fallback if JS interop fails
            return false;
        }
    }

    private string GetChatItemClass(int chatId)
    {
        return chatId == _selectedChatId 
            ? "border-left: 3px solid var(--mud-palette-primary); background-color: var(--mud-palette-primary-hover);" 
            : "";
    }

    private string GetLastMessagePreview(int chatId)
    {
        if (_lastMessages.TryGetValue(chatId, out var message))
        {
            var senderPrefix = message.IsCurrentUser ? "You: " : $"{message.SenderUserName}: ";
            return $"{senderPrefix}{message.Content}";
        }
        return "No messages";
    }

    private async Task OpenNewChatDialog()
    {
        var options = new DialogOptions { 
            CloseOnEscapeKey = true, 
            CloseButton = true,
            MaxWidth = MaxWidth.ExtraSmall
        };
        
        var parameters = new DialogParameters
        {
            { "OnChatCreated", EventCallback.Factory.Create<ChatRoom>(this, OnChatCreated) }
        };
        
        await DialogService.ShowAsync<NewChatDialog>("New Chat", parameters, options);
    }

    private async Task OnChatCreated(ChatRoom chatRoom)
    {
        // Add new chat to list
        _chatRooms.Add(chatRoom);
        
        // Join the chat room
        if (ChatHubService.IsConnected)
        {
            await ChatHubService.JoinChatRoomAsync(chatRoom.Id);
        }
        
        // Select the new chat
        await SelectChat(chatRoom);
    }

    public ValueTask DisposeAsync()
    {
        _typingTimer?.Dispose();
        
        if (_connectionInitialized)
        {
            ChatHubService.OnReceiveMessage -= HandleReceiveMessage;
            ChatHubService.OnUserTyping -= HandleUserTyping;
            ChatHubService.OnUserStoppedTyping -= HandleUserStoppedTyping;
            ChatHubService.OnError -= HandleError;
        }

        return ValueTask.CompletedTask;
    }
}